<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../../../../../style.css">
    <base target="_parent">
  </head>
  
  <body>
    <div class="content">
       <h1>Selection Sort</h1>

      <div class="ck-content">
        <p style="margin-left:0px;">Pros of Selection Sort:</p>
        <ol>
          <li style="margin-left:0px;"><strong>Simplicity</strong>: Selection Sort is one of the simplest sorting
            algorithms to understand and implement. It is often used as an educational
            example to teach the concept of sorting algorithms.</li>
          <li style="margin-left:0px;"><strong>In-Place Sorting</strong>: Selection Sort can be implemented in
            an in-place manner, meaning it doesn't require additional memory for sorting,
            other than a few temporary variables. This makes it memory-efficient.</li>
          <li
          style="margin-left:0px;"><strong>Minimal Swapping</strong>: Unlike some other sorting algorithms,
            such as Bubble Sort, Selection Sort only performs a limited number of swaps
            (in the order of n), which can be an advantage in situations where swapping
            is expensive or not allowed.</li>
        </ol>
        <p style="margin-left:0px;">Cons of Selection Sort:</p>
        <ol>
          <li style="margin-left:0px;"><strong>Inefficiency</strong>: Selection Sort has a time complexity of
            O(n^2) in the worst case and average case, where 'n' is the number of elements.
            This makes it highly inefficient for sorting large datasets. For practical
            purposes, it is usually outperformed by more efficient sorting algorithms
            like Quick Sort, Merge Sort, or even Insertion Sort.</li>
          <li style="margin-left:0px;"><strong>Lack of Adaptivity</strong>: Selection Sort's performance remains
            the same regardless of the initial order of the elements. It does not adapt
            well to partially sorted data, making it suboptimal in many real-world
            scenarios.</li>
          <li style="margin-left:0px;"><strong>Unstable Sorting</strong>: Selection Sort is an unstable sorting
            algorithm, meaning it may not preserve the relative order of equal elements.
            If maintaining the order of equal elements is important, you may need to
            use a stable sorting algorithm like Merge Sort.</li>
          <li style="margin-left:0px;"><strong>Redundant Comparisons</strong>: Selection Sort makes many redundant
            comparisons, especially when the data is mostly sorted. This results in
            extra time wasted on comparing elements that do not need to be compared.</li>
          <li
          style="margin-left:0px;"><strong>Lack of Practical Use</strong>: Due to its inefficiency, Selection
            Sort is rarely used in real-world applications. There are much faster and
            more practical sorting algorithms available that are better suited for
            sorting tasks of any size.</li>
        </ol><pre><code class="language-text-plain">void selectionSort(int arr[], int size) {
    for (int i = 0; i &lt; size - 1; i++) {
        int minIndex = i;

        // Find the index of the minimum element in the unsorted part of the array
        for (int j = i + 1; j &lt; size; j++) {
            if (arr[j] &lt; arr[minIndex]) {
                minIndex = j;
            }
        }

        // Swap the minimum element with the first unsorted element
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}</code></pre>
      </div>
    </div>
  </body>

</html>