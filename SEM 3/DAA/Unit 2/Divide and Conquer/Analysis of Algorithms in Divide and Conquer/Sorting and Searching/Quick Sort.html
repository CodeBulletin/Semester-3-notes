<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../../../../../style.css">
    <base target="_parent">
  </head>
  
  <body>
    <div class="content">
       <h1>Quick Sort</h1>

      <div class="ck-content">
        <h3 style="margin-left:0px;"><strong>Pros of Quick Sort:</strong></h3>
        <ol>
          <li><strong>Efficiency</strong>: Quick Sort is one of the fastest sorting
            algorithms on average. It has an average-case time complexity of O(n*log(n)),
            which makes it very efficient for sorting large datasets.</li>
          <li><strong>In-place Sorting</strong>: Quick Sort can be implemented in an
            in-place manner, meaning it doesn't require additional memory for sorting,
            other than the stack used for recursive calls. This makes it memory-efficient.</li>
          <li><strong>Good for Large Datasets</strong>: Quick Sort is particularly well-suited
            for sorting large datasets, as its average-case performance is very good.
            It's often used in practice for this reason.</li>
          <li><strong>Adaptive</strong>: Quick Sort is adaptive, which means its performance
            can be improved if the dataset is partially sorted or nearly sorted. In
            such cases, it can have a time complexity close to O(n).</li>
          <li><strong>Simplicity</strong>: The basic algorithm for Quick Sort is relatively
            simple to understand and implement, especially when using a simple pivot
            selection strategy.</li>
        </ol>
        <h3 style="margin-left:0px;"><strong>Cons of Quick Sort:</strong></h3>
        <ol>
          <li><strong>Worst-Case Time Complexity</strong>: The worst-case time complexity
            of Quick Sort is O(n^2), which occurs when the pivot chosen in each step
            consistently results in highly unbalanced partitions. This can happen when
            the dataset is already sorted or nearly sorted. However, this can be mitigated
            by using randomized pivot selection or other strategies.</li>
          <li><strong>Unstable</strong>: Quick Sort is an unstable sorting algorithm,
            meaning it may not preserve the relative order of equal elements. If maintaining
            the order of equal elements is important, you may need to use a stable
            sorting algorithm like Merge Sort.</li>
          <li><strong>Pivot Selection</strong>: The choice of pivot can greatly affect
            the performance of Quick Sort. Poor pivot selection strategies can lead
            to inefficient sorting, which may require additional measures to mitigate.</li>
          <li><strong>Recursive Depth</strong>: Quick Sort is a recursive algorithm,
            and if not properly optimized, it can lead to a large recursive depth for
            certain datasets. This can cause a stack overflow, particularly for very
            large datasets.</li>
          <li><strong>Not Suitable for Linked Lists</strong>: Quick Sort is less efficient
            when sorting linked lists compared to arrays, due to the lack of efficient
            random access. Merge Sort is often a better choice for sorting linked lists.</li>
        </ol><pre><code class="language-text-plain">int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);

    for (int j = low; j &lt;= high - 1; j++) {
        if (arr[j] &lt; pivot) {
            i++;
            swap(&amp;arr[i], &amp;arr[j]);
        }
    }
    swap(&amp;arr[i + 1], &amp;arr[high]);
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low &lt; high) {
        int pi = partition(arr, low, high);

        // Sort elements before and after the partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}</code></pre>
        <h2><strong>Performance Analysis</strong></h2>
        <h4><strong>Worst Case:</strong></h4>
        <figure class="image">
          <img src="Quick%20Sort/Screenshot_10-1.png" alt="Worst Case of Quick Sort">
        </figure>
        <p><span class="math-tex">\(T(n) = T(n-1) + n\)</span>
        </p>
        <p>Solving with Substitution we get</p>
        <p><span class="math-tex">\(T(n) = n + (n -1) + (n-2)+...+ (n-n+1)\)</span>&nbsp;</p>
        <p><span class="math-tex">\(\implies T(n) = n^2 - (1 + 2 + 3 + ... + n - 1)\)</span>
        </p>
        <p><span class="math-tex">\(\implies T(n) = n^2 - \frac{n(n-1)}2\)</span>
        </p>
        <p><span class="math-tex">\(\implies T(n) = n^2 - \frac{n^2}2 + \frac{n}{2}\)</span>
        </p>
        <p><span class="math-tex">\(\implies T(n) = \frac{n^2}2 + \frac{n}2\)</span>
        </p>
        <p><span class="math-tex">\(\implies T(n) = O(n^2)\)</span>
        </p>
        <h4><strong>Best Case</strong></h4>
        <figure class="image">
          <img src="Quick%20Sort/image.jpg" alt="Analysis of quicksort (article) | Quick sort | Khan Academy">
        </figure>
        <p><span class="math-tex">\(T(n) = 2T(\frac{n}2) + n\)</span>
        </p>
        <p><span class="math-tex">\(\implies T(n) = n^{log_b{a}} * U(n)\)</span>
        </p>
        <p><span class="math-tex">\(\implies T(n) = n * U(n)\)</span>
        </p>
        <p><span class="math-tex">\(now, \space h(n) = \frac{f(n)}{n^{log_b(a)}} = 1 = log(n)^0 \implies U(n) &nbsp;= log_2(n)\)</span>
        </p>
        <p><span class="math-tex">\(\implies T(n) = n * log_2(n) = O(nlogn)\)</span>
        </p>
        <h4><strong>Average Case</strong></h4>
        <p><span class="math-tex">\(T(n) = T(\frac{n}{10})+T(\frac{9n}{10}) + n\)</span>
        </p>
        <p><span class="math-tex">\(\implies T(n) = n * log_{10/9}(n)\)</span>
        </p>
        <p><span class="math-tex">\(\implies T(n) = O(nlog(n))\)</span>
        </p>
      </div>
    </div>
  </body>

</html>