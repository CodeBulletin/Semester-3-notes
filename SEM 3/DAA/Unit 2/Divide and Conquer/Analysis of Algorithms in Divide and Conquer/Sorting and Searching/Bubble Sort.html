<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../../../../../style.css">
    <base target="_parent">
  </head>
  
  <body>
    <div class="content">
       <h1>Bubble Sort</h1>

      <div class="ck-content">
        <h3 style="margin-left:0px;"><strong>Pros of Bubble Sort:</strong></h3>
        <ol>
          <li><strong>Simplicity</strong>: Bubble Sort is one of the simplest sorting
            algorithms to understand and implement. It is often used as a teaching
            tool to introduce the concept of sorting algorithms.</li>
          <li><strong>In-Place Sorting</strong>: Bubble Sort can be implemented in an
            in-place manner, meaning it doesn't require additional memory for sorting,
            other than a few temporary variables. This makes it memory-efficient.</li>
        </ol>
        <h3 style="margin-left:0px;"><strong>Cons of Bubble Sort:</strong></h3>
        <ol>
          <li><strong>Inefficiency</strong>: Bubble Sort has a worst-case and average-case
            time complexity of O(n^2). This means it is highly inefficient for sorting
            large datasets. For practical purposes, it is almost always outperformed
            by more efficient sorting algorithms, such as Quick Sort, Merge Sort, or
            even Insertion Sort.</li>
          <li><strong>Lack of Adaptivity</strong>: Bubble Sort's performance remains
            the same regardless of the initial order of the elements. It does not adapt
            well to partially sorted data, making it suboptimal in many real-world
            scenarios.</li>
          <li><strong>Unstable Sorting</strong>: Bubble Sort is an unstable sorting
            algorithm, meaning it may not preserve the relative order of equal elements.
            If maintaining the order of equal elements is important, you may need to
            use a stable sorting algorithm like Merge Sort.</li>
          <li><strong>Redundant Comparisons</strong>: Bubble Sort makes many redundant
            comparisons, especially when the data is mostly sorted. This results in
            extra time wasted on comparing elements that do not need to be compared.</li>
          <li><strong>Lack of Practical Use</strong>: Due to its inefficiency, Bubble
            Sort is rarely used in real-world applications. There are much faster and
            more practical sorting algorithms available that are better suited for
            sorting tasks of any size.</li>
        </ol><pre><code class="language-text-x-c-src">void bubbleSort(int arr[], int size) {
   for (int i = 0; i &lt; size - 1; i++) {
       // Last i elements are already in place
       for (int j = 0; j &lt; size - i - 1; j++) {
           // Compare adjacent elements
           if (arr[j] &gt; arr[j + 1]) {
               // Swap elements if the current element is greater than the next element
               int temp = arr[j];
               arr[j] = arr[j + 1];
               arr[j + 1] = temp;
           }
       }
   }
}</code></pre>
        <figure class="image">
          <img src="../../../../Unit%201/Sorting%20Algorithms/Bubble%20Sort%20Proof%20and%20Time%20Complexity/image.png">
        </figure>
      </div>
    </div>
  </body>

</html>