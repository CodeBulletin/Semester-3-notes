<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../../../../../style.css">
    <base target="_parent">
  </head>
  
  <body>
    <div class="content">
       <h1>Merge Sort</h1>

      <div class="ck-content">
        <h3 style="margin-left:0px;"><strong>Pros of Merge Sort:</strong></h3>
        <ol>
          <li style="margin-left:0px;"><strong>Stable Sorting</strong>: Merge Sort is a stable sorting algorithm,
            meaning it preserves the relative order of equal elements. This makes it
            useful when sorting records or objects with multiple attributes, where
            you want to maintain the existing order of records with equal key values.</li>
          <li
          style="margin-left:0px;"><strong>Guaranteed Worst-Case Performance</strong>: Merge Sort has a consistent
            worst-case time complexity of O(n*log(n)), regardless of the initial order
            of the elements. This makes it a reliable choice for sorting large datasets,
            as it does not suffer from worst-case scenarios like Quick Sort.</li>
            <li
            style="margin-left:0px;"><strong>External Sorting</strong>: Merge Sort is suitable for external
              sorting, which involves sorting data that does not fit entirely in memory.
              It can efficiently sort data stored on external storage devices like hard
              drives or tapes.</li>
              <li style="margin-left:0px;"><strong>Predictable and Consistent</strong>: Merge Sort consistently provides
                good performance and is not dependent on the distribution of the data.
                This predictability is important in applications where worst-case performance
                cannot be tolerated.</li>
              <li style="margin-left:0px;"><strong>Divide and Conquer</strong>: Merge Sort's divide-and-conquer approach
                is easy to understand and implement. It breaks the sorting problem into
                smaller subproblems, making it a good educational example.</li>
        </ol>
        <h3 style="margin-left:0px;"><strong>Cons of Merge Sort:</strong></h3>
        <ol>
          <li style="margin-left:0px;"><strong>Space Complexity</strong>: Merge Sort typically requires additional
            memory space to merge subarrays, which can be a drawback when sorting large
            datasets, especially if memory is limited. This makes it less memory-efficient
            compared to some in-place sorting algorithms like Quick Sort.</li>
          <li style="margin-left:0px;"><strong>Slower for Small Datasets</strong>: Merge Sort's overhead in terms
            of function calls and memory usage makes it slower than some other algorithms,
            such as Quick Sort or Insertion Sort, for small datasets. It shines when
            sorting larger datasets.</li>
          <li style="margin-left:0px;"><strong>Slower for Sequential Access Data</strong>: Merge Sort is slower
            when sorting data with poor locality, such as linked lists, as it involves
            more random access to elements, which can lead to cache inefficiency.</li>
          <li
          style="margin-left:0px;"><strong>Not Adaptive</strong>: Merge Sort's performance is not adaptive.
            It has a consistent time complexity of O(n*log(n)) regardless of the initial
            order of elements. Quick Sort, on the other hand, can be adaptive when
            the data is partially sorted.</li>
        </ol><pre><code class="language-text-plain">// Function to merge two subarrays of arr[]
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
void merge(int arr[], int l, int m, int r) {
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    // Create temporary arrays
    int *L, *R;
    
    L = (int*) malloc(sizeof(int) * n1);
    R = (int*) malloc(sizeof(int) * n2);

    // Copy data to temporary arrays L[] and R[]
    for (i = 0; i &lt; n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j &lt; n2; j++)
        R[j] = arr[m + 1 + j];

    // Merge the temporary arrays back into arr[l..r]
    i = 0; // Initial index of first subarray
    j = 0; // Initial index of second subarray
    k = l; // Initial index of merged subarray

    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[], if there are any
    while (i &lt; n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[], if there are any
    while (j &lt; n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
    free(L);
    free(R);
}

// Main function that sorts arr[l..r] using merge()
void mergeSort(int arr[], int l, int r) {
    if (l &lt; r) {
        // Same as (l+r)/2, but avoids overflow for large l and h
        int m = l + (r - l) / 2;

        // Sort first and second halves
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);

        merge(arr, l, m, r);
    }
}</code></pre>
      </div>
    </div>
  </body>

</html>