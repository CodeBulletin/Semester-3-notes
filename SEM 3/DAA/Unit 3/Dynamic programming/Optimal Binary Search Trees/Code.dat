def optimalBST(keys, freq, n):
    # Initialize weight and cost matrices
    w = [[0 for x in range(n+1)] for y in range(n+1)]
    c = [[0 for x in range(n+1)] for y in range(n+1)]
    r = [[0 for x in range(n+1)] for y in range(n+1)]

    # Calculate weights
    for i in range(n):
        w[i][i+1] = freq[i]
        for j in range(i+2, n+1):
            w[i][j] = w[i][j-1] + freq[j-1]

    # Compute optimal costs
    for length in range(1, n+1):  # Chain length
        for i in range(n-length+1):
            j = i + length
            c[i][j] = float('inf')
            for k in range(i, j):  # Try making k the root
                cost = c[i][k] + c[k+1][j] + w[i][j]
                if cost < c[i][j]:
                    c[i][j] = cost
                    r[i][j] = k+1
                    
    return c[0][n], r