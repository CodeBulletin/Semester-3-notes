<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../../style.css">
    <base target="_parent">
  </head>
  
  <body>
    <div class="content">
       <h1>Q1</h1>

      <div class="ck-content">
        <h2>A) Diff b/w big oh (O) and little oh (o) asymptotic functions</h2>
        <p style="margin-left:0px;">Big O (O) and little o (o) are both notations used in computer science
          and mathematics to describe the asymptotic behavior of functions, particularly
          in the context of algorithm analysis. However, they represent different
          levels of growth or bounds:</p>
        <p style="margin-left:0px;">Big O (O):</p>
        <ul>
          <li>Big O notation, often referred to as "order of" notation, describes an
            upper bound on the growth rate of a function.</li>
          <li>It is used to denote an upper limit on the rate of growth of a function,
            specifically, an upper bound on the magnitude of the function for all values
            greater than a certain point.</li>
          <li>Formally, a function f(n) is said to be O(g(n)) if there exist constants
            c and n₀ such that for all n ≥ n₀, |f(n)| ≤ c * |g(n)|. This means that
            f(n) grows at most as fast as g(n) for sufficiently large n.</li>
        </ul>
        <p style="margin-left:0px;">Little o (o):</p>
        <ul>
          <li>Little o notation represents a stricter condition than Big O notation.
            It describes a function that grows strictly slower than another function.</li>
          <li>It is used to denote a tighter upper bound on the growth rate of a function.
            Formally, a function f(n) is said to be o(g(n)) if, for all constants c
            &gt; 0, there exists a constant n₀ such that for all n ≥ n₀, |f(n)| &lt;
            c * |g(n)|. This means that f(n) grows strictly slower than g(n) for sufficiently
            large n.</li>
        </ul>
        <p style="margin-left:0px;">In summary, Big O notation provides an upper bound on the growth rate
          of a function, indicating that the function does not grow faster than a
          certain rate. Little o notation, on the other hand, indicates that the
          function grows strictly slower than another function, implying a more precise
          bound on the growth rate. Little o is often used when you want to describe
          a function's growth that is significantly smaller than another function.</p>
        <h2>B) “Sorting of list” is mandatory before “merging of list” in merge sort. Justify can we merge unsorted lists to get sorted list</h2>
        <p style="margin-left:0px;">Merging unsorted lists directly to obtain a sorted list is not a feasible
          or efficient approach. Merge sort, as a divide-and-conquer sorting algorithm,
          requires that the input list be divided into smaller, sorted sublists before
          merging. This is a fundamental aspect of the algorithm, and there are several
          reasons why merging unsorted lists directly is not a viable option:</p>
        <ul>
          <li style="margin-left:0px;"><strong>Lack of Order</strong>: Merging unsorted lists would result in
            a chaotic combination of elements, making it impossible to determine the
            correct order of elements in the merged list. The fundamental assumption
            in merge sort is that the sublists being merged are already sorted.</li>
          <li
          style="margin-left:0px;"><strong>Incorrect Results</strong>: Merging unsorted lists would produce
            an incorrect and unsorted merged list. This is because there is no guarantee
            that the elements in one unsorted list would be greater or smaller than
            the elements in another unsorted list.</li>
            <li style="margin-left:0px;"><strong>Loss of Efficiency</strong>: Merge sort is known for its efficiency
              and effectiveness in sorting large datasets. However, the efficiency of
              the algorithm is based on the divide-and-conquer strategy, which relies
              on merging sorted sublists. Merging unsorted lists would result in a loss
              of this efficiency and could lead to a significantly slower sorting process.</li>
        </ul>
        <p style="margin-left:0px;">To apply merge sort correctly, you should always start with a list that
          is divided into smaller, sorted sublists (typically of size 1) and then
          merge these sublists in a way that maintains the order. This approach ensures
          that the elements are correctly sorted during the merge process and allows
          merge sort to achieve its desired time complexity of O(n log n), where
          n is the size of the input list.</p>
        <p>&nbsp;</p>
        <h2>C) Evaluate number of multiplications and additions needed to multiply two matrices of order n using traditional Matrix MULTIPLICATION method</h2>
        <p style="margin-left:0px;">The traditional method for multiplying two matrices of order n (where
          each matrix is n x n) is known as the "matrix multiplication" method, also
          called the "naive" method. In this method, you perform a series of dot
          products to compute each element of the resulting matrix. To evaluate the
          number of multiplications and additions needed for this operation, let's
          break it down step by step:</p>
        <p style="margin-left:0px;">Suppose you have two matrices, A and B, both of order n x n, and you want
          to compute the product C = A * B.</p>
        <ol>
          <li style="margin-left:0px;">For each element c[i][j] in the resulting matrix C, you need to compute
            a dot product of a row from matrix A and a column from matrix B. Each dot
            product involves n multiplications and (n-1) additions because the first
            multiplication doesn't require an addition.
            <br>
            <br>Since there are n x n elements in the resulting matrix C, you will perform
            this dot product n x n times.
            <br>
            <br>So, the number of multiplications required is n x n x n = n^3 multiplications.
            <br>&nbsp;</li>
          <li style="margin-left:0px;">Additionally, for each dot product, you need (n-1) additions. Since you
            have n x n dot products to compute, the total number of additions required
            is (n-1) x n x n = n^2 x (n-1) additions.</li>
        </ol>
        <p style="margin-left:0px;">In summary, when using the traditional matrix multiplication method to
          multiply two n x n matrices, you need:</p>
        <ul>
          <li>n^3 multiplications</li>
          <li>n^2 x (n-1) additions</li>
        </ul>
        <h2>D) Illustrate randomized algorithm with the help of an example</h2>
        <p style="margin-left:0px;">Randomized algorithms are algorithms that use randomness or random inputs
          as part of their computation. They are often used when a deterministic
          algorithm might be too slow or when an approximate solution is acceptable.
          A classic example of a randomized algorithm is the Monte Carlo method,
          which is commonly used for estimating numerical values by generating random
          samples. Let's illustrate this with an example:</p>
        <p style="margin-left:0px;"><strong>Example: Estimating π using the Monte Carlo method</strong>
        </p><pre><code class="language-text-x-c-src">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

using namespace std;

int main() {
    // Seed the random number generator with the current time
    srand(time(0));

    int totalPoints = 1000000;  // Total number of random points to generate
    int pointsInsideCircle = 0; // Counter for points inside the quarter-circle

    // Generate random points and check if they are inside the quarter-circle
    for (int i = 0; i &lt; totalPoints; i++) {
        double x = static_cast&lt;double&gt;(rand()) / RAND_MAX; // Random x-coordinate between 0 and 1
        double y = static_cast&lt;double&gt;(rand()) / RAND_MAX; // Random y-coordinate between 0 and 1
        
        // Check if the point (x, y) is inside the quarter-circle (x^2 + y^2 &lt;= 1)
        if (x * x + y * y &lt;= 1.0) {
            pointsInsideCircle++;
        }
    }

    // Calculate the estimated value of π
    double estimatedPi = 4.0 * static_cast&lt;double&gt;(pointsInsideCircle) / totalPoints;

    // Output the estimated value of π
    cout &lt;&lt; "Estimated value of π: " &lt;&lt; estimatedPi &lt;&lt; endl;

    return 0;
}</code></pre>
        <h2>E) Define loop invariant.</h2>
        <p style="margin-left:0px;">
          <br>A loop invariant is a logical condition or property that holds true before
          and after each iteration of a loop in a computer program. It is an essential
          concept in program correctness and loop analysis, particularly in the context
          of formal methods and program verification. Loop invariants are used to
          reason about the correctness of loops and to prove that a loop terminates
          and produces the desired result.</p>
        <p style="margin-left:0px;">A loop invariant typically consists of three key components:</p>
        <ol>
          <li style="margin-left:0px;">Initialization: The loop invariant holds true before the first iteration
            of the loop. It represents the base case or the initial condition that
            ensures the correctness of the loop.</li>
          <li style="margin-left:0px;">Maintenance: Assuming that the loop invariant holds true before a given
            iteration of the loop, it should also hold true after the iteration. In
            other words, the loop body must preserve the loop invariant during each
            iteration.</li>
          <li style="margin-left:0px;">Termination: The loop invariant, along with an additional condition, ensures
            that the loop eventually terminates. This additional condition might involve
            the loop control variable reaching a certain value or a specific condition
            becoming false.</li>
        </ol>
        <p style="margin-left:0px;">The primary purpose of a loop invariant is to provide a formal proof that
          the loop will terminate correctly and produce the expected output. Loop
          invariants are used to reason about the correctness of algorithms and to
          demonstrate that the algorithm satisfies its intended specifications. They
          are a crucial tool in the fields of formal methods, program correctness,
          and algorithm analysis.</p>
      </div>
    </div>
  </body>

</html>